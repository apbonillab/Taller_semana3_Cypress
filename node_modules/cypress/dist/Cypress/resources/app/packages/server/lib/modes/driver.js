(function() {
  var Project, Promise, Reporter, collectTestResults, errors, fs, humanTime, log, openProject, pkg, random, stats, terminal;

  fs = require("fs-extra");

  Promise = require("bluebird");

  random = require("randomstring");

  stats = require("../stats");

  errors = require("../errors");

  Project = require("../project");

  Reporter = require("../reporter");

  openProject = require("../open_project");

  terminal = require("../util/terminal");

  humanTime = require("../util/human_time");

  pkg = require("../../package.json");

  log = require("../log");

  fs = Promise.promisifyAll(fs);

  collectTestResults = function(obj) {
    return {
      tests: obj.tests,
      passes: obj.passes,
      pending: obj.pending,
      failures: obj.failures,
      duration: humanTime(obj.duration),
      version: pkg.version
    };
  };

  module.exports = {
    collectTestResults: collectTestResults,
    getId: function() {
      return random.generate({
        length: 5,
        capitalization: "lowercase"
      });
    },
    openProject: function(id, options) {
      var ref;
      return openProject.create(options.projectPath, options, {
        morgan: false,
        socketId: id,
        report: true,
        isTextTerminal: (ref = options.isTextTerminal) != null ? ref : true
      })["catch"]({
        portInUse: true
      }, function(err) {
        return errors["throw"]("PORT_IN_USE_LONG", err.port);
      });
    },
    displayStats: function(obj) {
      var bgColor, color;
      if (obj == null) {
        obj = {};
      }
      bgColor = obj.failures ? "bgRed" : "bgGreen";
      color = obj.failures ? "red" : "green";
      console.log("");
      terminal.header("Tests Finished", {
        color: [color]
      });
      console.log("");
      return stats.display(color, obj);
    },
    launchBrowser: function(options) {
      var browser, browserOpts, spec;
      if (options == null) {
        options = {};
      }
      browser = options.browser, spec = options.spec;
      browserOpts = {};
      return openProject.launch(browser, spec, browserOpts);
    },
    listenForProjectEnd: function(project, gui) {
      return new Promise(function(resolve) {
        var onEarlyExit, onEnd;
        if (gui) {
          return;
        }
        onEarlyExit = function(errMsg) {
          var obj;
          obj = {
            error: errors.stripAnsi(errMsg),
            failures: 1,
            tests: 0,
            passes: 0,
            pending: 0,
            duration: 0,
            failingTests: []
          };
          return resolve(obj);
        };
        onEnd = (function(_this) {
          return function(obj) {
            return resolve(obj);
          };
        })(this);
        project.once("end", onEnd);
        return project.once("exitEarlyWithErr", onEarlyExit);
      });
    },
    waitForBrowserToConnect: function(options) {
      var attempts, id, project, timeout, waitForBrowserToConnect;
      if (options == null) {
        options = {};
      }
      project = options.project, id = options.id, timeout = options.timeout;
      attempts = 0;
      return (waitForBrowserToConnect = (function(_this) {
        return function() {
          return Promise.join(_this.waitForSocketConnection(project, id), _this.launchBrowser(options)).timeout(timeout != null ? timeout : 30000)["catch"](Promise.TimeoutError, function(err) {
            attempts += 1;
            console.log("");
            return openProject.closeBrowser().then(function() {
              var word;
              switch (attempts) {
                case 1:
                case 2:
                  word = attempts === 1 ? "Retrying..." : "Retrying again...";
                  errors.warning("TESTS_DID_NOT_START_RETRYING", word);
                  return waitForBrowserToConnect();
                default:
                  err = errors.get("TESTS_DID_NOT_START_FAILED");
                  errors.log(err);
                  return project.emit("exitEarlyWithErr", err.message);
              }
            });
          });
        };
      })(this))();
    },
    waitForSocketConnection: function(project, id) {
      return new Promise(function(resolve, reject) {
        var fn;
        fn = function(socketId) {
          if (socketId === id) {
            project.removeListener("socket:connected", fn);
            return resolve();
          }
        };
        return project.on("socket:connected", fn);
      });
    },
    waitForTestsToFinishRunning: function(options) {
      var gui, project, started;
      if (options == null) {
        options = {};
      }
      project = options.project, gui = options.gui, started = options.started;
      return this.listenForProjectEnd(project, gui).then((function(_this) {
        return function(obj) {
          var finish, testResults;
          testResults = collectTestResults(obj);
          finish = function() {
            return project.getConfig().then(function(cfg) {
              return obj.config = cfg;
            })["return"](obj);
          };
          _this.displayStats(testResults);
          return finish();
        };
      })(this));
    },
    allDone: function() {
      console.log("");
      console.log("");
      terminal.header("All Done", {
        color: ["gray"]
      });
      return console.log("");
    },
    runTests: function(options) {
      var browser;
      if (options == null) {
        options = {};
      }
      browser = options.browser;
      log("runTests with options %j", Object.keys(options));
      log("runTests for browser " + browser);
      terminal.header("Tests Starting", {
        color: ["gray"]
      });
      return Promise.props({
        stats: this.waitForTestsToFinishRunning({
          project: options.project
        }),
        connection: this.waitForBrowserToConnect({
          id: options.id,
          spec: options.spec,
          project: options.project,
          webSecurity: options.webSecurity,
          browser: browser
        })
      });
    },
    run: function(options) {
      var id;
      log("driver mode ready with options %j", Object.keys(options));
      id = this.getId();
      return this.openProject(id, options).call("getProject").then((function(_this) {
        return function(project) {
          return project.getConfig().then(function(config) {
            return _this.runTests({
              id: id,
              project: project,
              videosFolder: config.videosFolder,
              videoRecording: config.videoRecording,
              videoCompression: config.videoCompression,
              spec: options.spec,
              gui: options.showHeadlessGui,
              browser: options.browser,
              outputPath: options.outputPath
            });
          }).get("stats")["finally"](function() {
            return _this.allDone();
          });
        };
      })(this));
    }
  };

}).call(this);
